<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Senior Swipe</title>
    <link rel="icon" type="image/png" href="icon.png">
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class', // Enable manual dark mode
        }
    </script>

    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-csharp.min.js"></script>

    <script src="data.js"></script>

    <style>
        body {
            touch-action: pan-y;
            -webkit-tap-highlight-color: transparent;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 3px;
        }

        .dark ::-webkit-scrollbar-thumb {
            background: #52525b;
        }

        .card-enter {
            animation: slideIn 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards;
        }

        @keyframes slideIn {
            from {
                transform: translateY(20px) scale(0.95);
                opacity: 0;
            }

            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }

        @keyframes pop {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(0.9);
            }

            100% {
                transform: scale(1);
            }
        }

        @keyframes slideOutLeft {
            to {
                transform: translateX(-50px);
                opacity: 0;
            }
        }

        @keyframes slideOutRight {
            to {
                transform: translateX(50px);
                opacity: 0;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(50px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .animate-pop {
            animation: pop 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .card-exit-left {
            animation: slideOutLeft 0.2s forwards;
        }

        .card-exit-right {
            animation: slideOutRight 0.2s forwards;
        }

        .card-enter-left {
            animation: slideInLeft 0.2s forwards;
        }

        .card-enter-right {
            animation: slideInRight 0.2s forwards;
        }

        /* Markdown Styles */
        .markdown-body strong {
            font-weight: 800;
            color: inherit;
        }

        .markdown-body em {
            font-style: italic;
            opacity: 0.8;
        }

        .markdown-body ul {
            list-style-type: disc;
            padding-left: 1.2em;
            margin-bottom: 0.5em;
        }

        .markdown-body li {
            margin-bottom: 0.25em;
        }

        .markdown-body p {
            margin-bottom: 0.75em;
        }

        .markdown-body code:not([class*="language-"]) {
            background: rgba(100, 116, 139, 0.1);
            padding: 2px 4px;
            border-radius: 4px;
            font-family: monospace;
            color: #ef4444;
            font-size: 0.9em;
        }

        .dark .markdown-body code:not([class*="language-"]) {
            background: rgba(255, 255, 255, 0.1);
            color: #f87171;
        }

        .markdown-body pre {
            border-radius: 0.5em;
            overflow-x: auto;
            margin-bottom: 1em;
            white-space: pre-wrap;
            /* Wrap code lines */
            word-break: break-all;
            /* Break long words if needed */
            max-width: 100%;
            /* Ensure it fits in card */
            background: #1e1e1e;
            /* Dark background for contrast */
            color: #d4d4d4;
            /* Light text */
            padding: 1em;
            /* Add padding */
        }

        /* 3D Flip Utilities */
        .perspective-1000 {
            perspective: 1000px;
        }

        .preserve-3d {
            transform-style: preserve-3d;
        }

        .backface-hidden {
            backface-visibility: hidden;
        }

        .rotate-y-180 {
            transform: rotateY(180deg);
        }
    </style>
</head>

<body class="bg-slate-100 dark:bg-zinc-950 transition-colors duration-300">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        const SRS = { AGAIN: 0, HARD: 1, GOOD: 2, EASY: 3 };

        // --- COMPONENTS ---
        const Markdown = ({ content }) => {
            useEffect(() => {
                if (window.Prism) window.Prism.highlightAll();
            }, [content]);

            return <div className="markdown-body text-sm leading-relaxed text-slate-600 dark:text-slate-300" dangerouslySetInnerHTML={{ __html: marked.parse(content || "") }} />;
        };

        const Toast = ({ message }) => (
            <div className="fixed bottom-8 left-1/2 -translate-x-1/2 bg-slate-900 dark:bg-white text-white dark:text-slate-900 px-6 py-3 rounded-full shadow-2xl z-50 flex items-center gap-3 card-enter">
                <span className="text-green-500"><Icons.CheckCircle size={18} /></span>
                <span className="text-sm font-bold">{message}</span>
            </div>
        );

        const Icon = ({ path, size = 20, className = "", fill = "none" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{path}</svg>
        );
        const Icons = {
            Heart: (p) => <Icon {...p} path={<path d="M19 14c1.49-1.46 3-3.21 3-5.5A5.5 5.5 0 0 0 16.5 3c-1.76 0-3 .5-4.5 2-1.5-1.5-2.74-2-4.5-2A5.5 5.5 0 0 0 2 8.5c0 2.3 1.5 4.05 3 5.5l7 7Z" />} />,
            X: (p) => <Icon {...p} path={<><path d="M18 6 6 18" /><path d="m6 6 12 12" /></>} />,
            Home: (p) => <Icon {...p} path={<path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />} />,
            Search: (p) => <Icon {...p} path={<><circle cx="11" cy="11" r="8" /><path d="m21 21-4.3-4.3" /></>} />,
            Bookmark: (p) => <Icon {...p} path={<path d="m19 21-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2v16z" />} />,
            Moon: (p) => <Icon {...p} path={<path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" />} />,
            Sun: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="4" /><path d="M12 2v2" /><path d="M12 20v2" /><path d="m4.93 4.93 1.41 1.41" /><path d="m17.66 17.66 1.41 1.41" /><path d="M2 12h2" /><path d="M20 12h2" /><path d="m6.34 17.66-1.41 1.41" /><path d="m19.07 4.93-1.41 1.41" /></>} />,
            CheckCircle: (p) => <Icon {...p} path={<><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14" /><polyline points="22 4 12 14.01 9 11.01" /></>} />,
            Alert: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10" /><line x1="12" x2="12" y1="8" y2="12" /><line x1="12" x2="12.01" y1="16" y2="16" /></>} />,
            EyeOff: (p) => <Icon {...p} path={<><path d="M9.88 9.88a3 3 0 1 0 4.24 4.24" /><path d="M10.73 5.08A10.43 10.43 0 0 1 12 5c7 0 10 7 10 7a13.16 13.16 0 0 1-1.67 2.68" /><path d="M6.61 6.61A13.526 13.526 0 0 0 2 12s3 7 10 7a9.74 9.74 0 0 0 5.39-1.61" /><line x1="2" x2="22" y1="2" y2="22" /></>} />,
            Globe: (p) => <Icon {...p} path={<><circle cx="12" cy="12" r="10" /><path d="M2 12h20" /><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z" /></>} />,
            Robot: (p) => <Icon {...p} path={<><rect width="18" height="12" x="3" y="6" rx="2" /><circle cx="12" cy="12" r="2" /><path d="M12 6V3" /><path d="M8 6V4" /><path d="M16 6V4" /></>} />,
            Flame: (p) => <Icon {...p} path={<path d="M8.5 14.5A2.5 2.5 0 0 0 11 12c0-1.38-.5-2-1-3-1.072-2.143-.224-4.054 2-6 .5 2.5 2 4.9 4 6.5 2 1.6 3 3.5 3 5.5a7 7 0 1 1-14 0c0-1.1.2-2.2.5-3.3.3-1.07 1.5-2.2 2.5-3.2Z" />} />,
            Wrench: (p) => <Icon {...p} path={<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z" />} />,
            Play: (p) => <Icon {...p} path={<polygon points="5 3 19 12 5 21 5 3" />} />,
            Trophy: (p) => <Icon {...p} path={<><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6" /><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18" /><path d="M4 22h16" /><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22" /><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22" /><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z" /></>} />,
            Filter: (p) => <Icon {...p} path={<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3" />} />,
            Mic: (p) => <Icon {...p} path={<><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z" /><path d="M19 10v2a7 7 0 0 1-14 0v-2" /><line x1="12" x2="12" y1="19" y2="23" /><line x1="8" x2="16" y1="23" y2="23" /></>} />,
            Headphones: (p) => <Icon {...p} path={<><path d="M3 18v-6a9 9 0 0 1 18 0v6" /><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z" /></>} />,
            Stop: (p) => <Icon {...p} path={<rect x="6" y="6" width="12" height="12" rx="2" />} />
        };

        const SimpleConfetti = () => {
            const canvasRef = useRef(null);
            useEffect(() => {
                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                let particles = [];
                const colors = ['#6366f1', '#a855f7', '#ec4899', '#22c55e', '#eab308'];

                for (let i = 0; i < 150; i++) {
                    particles.push({
                        x: window.innerWidth / 2,
                        y: window.innerHeight / 2,
                        vx: (Math.random() - 0.5) * 20,
                        vy: (Math.random() - 0.5) * 20,
                        life: 100 + Math.random() * 50,
                        color: colors[Math.floor(Math.random() * colors.length)],
                        size: Math.random() * 5 + 2
                    });
                }

                const animate = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    particles.forEach((p, index) => {
                        p.x += p.vx;
                        p.y += p.vy;
                        p.vy += 0.5; // Gravity
                        p.life--;
                        p.size *= 0.99;

                        ctx.fillStyle = p.color;
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        ctx.fill();

                        if (p.life <= 0) particles.splice(index, 1);
                    });
                    if (particles.length > 0) requestAnimationFrame(animate);
                };
                animate();
            }, []);
            return <canvas ref={canvasRef} className="fixed inset-0 pointer-events-none z-[100]" />;
        };

        const SessionSetupModal = ({ isOpen, onClose, categories, onStart, totalCards }) => {
            if (!isOpen) return null;
            const [mode, setMode] = useState('smart'); // smart, sequential
            const [range, setRange] = useState({ limit: 15 });

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-end sm:items-center justify-center p-4 backdrop-blur-sm">
                    <div className="bg-white dark:bg-zinc-900 w-full max-w-sm rounded-2xl p-6 shadow-2xl animate-pop">
                        <div className="flex justify-between items-center mb-6">
                            <h3 className="text-lg font-bold text-slate-800 dark:text-white">Session Setup</h3>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600">Close</button>
                        </div>

                        <div className="space-y-6">
                            <div>
                                <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Sorting Strategy</label>
                                <div className="grid grid-cols-2 gap-2">
                                    <button onClick={() => setMode('smart')} className={`p-3 rounded-xl border text-sm font-bold transition-all ${mode === 'smart' ? 'bg-indigo-600 border-indigo-600 text-white' : 'border-slate-200 dark:border-zinc-800 text-slate-600 dark:text-zinc-400'}`}>
                                        âš¡ Smart Shuffle
                                    </button>
                                    <button onClick={() => setMode('sequential')} className={`p-3 rounded-xl border text-sm font-bold transition-all ${mode === 'sequential' ? 'bg-indigo-600 border-indigo-600 text-white' : 'border-slate-200 dark:border-zinc-800 text-slate-600 dark:text-zinc-400'}`}>
                                        ðŸ”¢ Sequential
                                    </button>
                                </div>
                                <p className="text-[10px] text-slate-400 mt-2">
                                    {mode === 'smart' ? 'Prioritizes new cards and mistakes. Best for learning.' : 'Orders questions by ID (e.g. 1001, 1002). Best for systematic review.'}
                                </p>
                            </div>

                            <div>
                                <label className="block text-xs font-bold text-slate-500 uppercase mb-2">Number of Questions</label>
                                <input type="number" value={range.limit} onChange={e => setRange({ ...range, limit: parseInt(e.target.value) })} className="w-full bg-slate-50 dark:bg-zinc-800 border-none rounded-lg p-3 text-center font-mono font-bold" placeholder="e.g. 15" />
                                <div className="flex justify-between text-[10px] text-slate-400 mt-1">
                                    <span>Available: {totalCards}</span>
                                    <span>Default: 15</span>
                                </div>
                            </div>

                            <button onClick={() => onStart(mode, range)} className="w-full py-4 bg-indigo-600 hover:bg-indigo-700 text-white rounded-xl font-bold text-lg shadow-lg shadow-indigo-500/30 transition-all active:scale-95">
                                Launch Session ðŸš€
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const LevelRoadmapModal = ({ isOpen, onClose, currentXp, currentLevel }) => {
            if (!isOpen) return null;
            // Generate levels 1-50
            const levels = [];
            for (let i = 1; i <= 50; i++) {
                // Formula: Math.sqrt(xp / 25) + 1 = level  =>  (level-1)^2 * 25 = xp
                const minXp = Math.pow(i - 1, 2) * 25;
                let title = "Intern";
                if (i >= 5) title = "Junior Dev";
                if (i >= 15) title = "Mid-Level Dev";
                if (i >= 30) title = "Senior Dev";
                if (i >= 40) title = "Staff Engineer";
                if (i >= 50) title = "Principal Architect";
                levels.push({ level: i, minXp, title });
            }

            const getProgress = (lvl) => {
                if (currentLevel > lvl.level) return 100;
                if (currentLevel < lvl.level) return 0;
                // Current level progress
                const nextLvlXp = Math.pow(lvl.level, 2) * 25;
                const prevLvlXp = Math.pow(lvl.level - 1, 2) * 25;
                return Math.min(100, Math.max(0, ((currentXp - prevLvlXp) / (nextLvlXp - prevLvlXp)) * 100));
            };


            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 backdrop-blur-sm" onClick={onClose}>
                    <div className="bg-white dark:bg-zinc-900 rounded-2xl w-full max-w-sm shadow-2xl border border-slate-200 dark:border-zinc-800 overflow-hidden max-h-[80vh] flex flex-col" onClick={e => e.stopPropagation()}>
                        <div className="p-4 border-b border-slate-100 dark:border-zinc-800 flex justify-between items-center bg-slate-50 dark:bg-zinc-800/50">
                            <h2 className="font-bold text-slate-800 dark:text-white flex items-center gap-2"><Icons.Trophy className="text-yellow-500" /> Career Roadmap</h2>
                            <button onClick={onClose} className="p-1 rounded-full hover:bg-slate-200 dark:hover:bg-zinc-700 text-slate-400"><Icons.X size={18} /></button>
                        </div>
                        <div className="overflow-y-auto p-4 space-y-3">
                            {levels.map(l => (
                                <div key={l.level} className={`flex items-center gap-3 p-3 rounded-xl border ${l.level === currentLevel ? 'border-indigo-500 bg-indigo-50 dark:bg-indigo-900/20' : l.level < currentLevel ? 'border-indigo-100 bg-white dark:bg-zinc-900 dark:border-zinc-800' : 'border-slate-100 dark:border-zinc-800 opacity-60'}`}>
                                    <div className={`w-8 h-8 rounded-full flex items-center justify-center font-bold text-xs ${l.level <= currentLevel ? 'bg-indigo-600 text-white' : 'bg-slate-200 dark:bg-zinc-700 text-slate-500'}`}>{l.level}</div>
                                    <div className="flex-1">
                                        <div className="flex justify-between items-center mb-1">
                                            <span className={`font-bold text-xs ${l.level === currentLevel ? 'text-indigo-600 dark:text-indigo-400' : 'text-slate-700 dark:text-slate-300'}`}>{l.title}</span>
                                            <span className="text-[10px] font-mono text-slate-400">{l.minXp} XP</span>
                                        </div>
                                        <div className="w-full bg-slate-200 dark:bg-zinc-700 h-1.5 rounded-full overflow-hidden">
                                            <div className="h-full bg-indigo-500 transition-all" style={{ width: `${getProgress(l)}%` }}></div>
                                        </div>
                                    </div>
                                    {l.level === currentLevel && <Icons.Wrench size={14} className="text-indigo-500 animate-spin-slow" />}
                                    {l.level < currentLevel && <Icons.CheckCircle size={14} className="text-indigo-400" />}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        };

        const CardCreatorView = ({ onClose, onSave, categories }) => {
            const [form, setForm] = useState({ title: '', category: categories[0] || 'General', difficulty: 'Senior', content: '', explanation: '' });

            const handleSubmit = () => {
                if (!form.title || !form.content) return alert("Title and Content are required.");
                onSave({ ...form, id: Date.now().toString() }); // Simple ID
            };

            return (
                <div className="fixed inset-0 z-50 flex justify-center items-end sm:items-center bg-black/50 backdrop-blur-sm animate-pop">
                    <div className="w-full max-w-md h-full sm:h-[90vh] bg-white dark:bg-zinc-950 flex flex-col shadow-2xl overflow-hidden sm:rounded-2xl">
                        <div className="p-4 border-b border-slate-100 dark:border-zinc-800 flex justify-between items-center">
                            <button onClick={onClose} className="text-slate-500 font-bold">Cancel</button>
                            <h2 className="font-bold text-lg">New Card</h2>
                            <button onClick={handleSubmit} className="text-indigo-600 font-bold">Save</button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-6 space-y-6">
                            <div>
                                <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Title</label>
                                <input type="text" className="w-full p-3 bg-slate-50 dark:bg-zinc-900 rounded-xl" placeholder="e.g. Rate Limiting" value={form.title} onChange={e => setForm({ ...form, title: e.target.value })} />
                            </div>
                            <div className="grid grid-cols-2 gap-4">
                                <div>
                                    <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Category</label>
                                    <select className="w-full p-3 bg-slate-50 dark:bg-zinc-900 rounded-xl" value={form.category} onChange={e => setForm({ ...form, category: e.target.value })}>
                                        {categories.map(c => <option key={c} value={c}>{c}</option>)}
                                        <option value="User Added">User Added</option>
                                    </select>
                                </div>
                                <div>
                                    <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Difficulty</label>
                                    <select className="w-full p-3 bg-slate-50 dark:bg-zinc-900 rounded-xl" value={form.difficulty} onChange={e => setForm({ ...form, difficulty: e.target.value })}>
                                        <option value="Junior">Junior</option>
                                        <option value="Senior">Senior</option>
                                        <option value="Principal">Principal</option>
                                    </select>
                                </div>
                            </div>
                            <div>
                                <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Question (Markdown)</label>
                                <textarea className="w-full p-3 bg-slate-50 dark:bg-zinc-900 rounded-xl h-32 font-mono text-sm" placeholder="# Question..." value={form.content} onChange={e => setForm({ ...form, content: e.target.value })} />
                            </div>
                            <div>
                                <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Explanation (Markdown)</label>
                                <textarea className="w-full p-3 bg-slate-50 dark:bg-zinc-900 rounded-xl h-32 font-mono text-sm" placeholder="The answer is..." value={form.explanation} onChange={e => setForm({ ...form, explanation: e.target.value })} />
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const SettingsModal = ({ isOpen, onClose, onExport, onImport, currentTheme, onThemeChange }) => {
            if (!isOpen) return null;
            const themes = [
                { id: 'prism-tomorrow', name: 'Tomorrow Night' },
                { id: 'prism-dracula', name: 'Dracula' }, // Requires correct URL
                { id: 'prism-solarizedlight', name: 'Solarized Light' },
                { id: 'prism-okaidia', name: 'Okaidia' }
            ];

            return (
                <div className="fixed inset-0 bg-black/50 z-50 flex items-center justify-center p-4 backdrop-blur-sm" onClick={onClose}>
                    <div className="bg-white dark:bg-zinc-900 w-full max-w-sm rounded-2xl p-6 shadow-2xl" onClick={e => e.stopPropagation()}>
                        <h3 className="text-lg font-bold mb-6 text-slate-800 dark:text-white">Settings</h3>

                        <div className="space-y-6">
                            <div>
                                <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Code Theme</label>
                                <div className="grid grid-cols-2 gap-2">
                                    {themes.map(t => (
                                        <button key={t.id} onClick={() => onThemeChange(t.id)} className={`p-2 rounded-lg text-xs font-bold border ${currentTheme === t.id ? 'border-indigo-500 bg-indigo-50 dark:bg-indigo-900/20 text-indigo-600' : 'border-slate-200 dark:border-zinc-800 text-slate-500'}`}>
                                            {t.name}
                                        </button>
                                    ))}
                                </div>
                            </div>

                            <div className="pt-4 border-t border-slate-100 dark:border-zinc-800">
                                <label className="block text-xs font-bold text-slate-400 uppercase mb-2">Data Management</label>
                                <div className="flex gap-2">
                                    <button onClick={onExport} className="flex-1 p-3 bg-slate-100 dark:bg-zinc-800 rounded-xl text-sm font-bold text-slate-600 dark:text-zinc-300">Backup Data</button>
                                    <label className="flex-1 cursor-pointer p-3 bg-indigo-600 rounded-xl text-sm font-bold text-white text-center hover:bg-indigo-700">
                                        Restore Data
                                        <input type="file" className="hidden" accept=".json" onChange={onImport} />
                                    </label>
                                </div>
                            </div>
                        </div>
                        <button onClick={onClose} className="w-full mt-6 py-3 text-slate-400 font-bold hover:text-slate-600">Close</button>
                    </div>
                </div>
            );
        };

        const RadarChart = ({ data, size = 200 }) => {
            const center = size / 2;
            const radius = (size / 2) - 20;
            const angleSlice = (Math.PI * 2) / data.length;

            // Coordinates
            const points = data.map((d, i) => {
                const r = (d.value / 100) * radius;
                const angle = i * angleSlice - Math.PI / 2;
                return `${center + r * Math.cos(angle)},${center + r * Math.sin(angle)}`;
            }).join(' ');

            // Axis lines
            const axes = data.map((d, i) => {
                const angle = i * angleSlice - Math.PI / 2;
                return (
                    <line key={i} x1={center} y1={center} x2={center + radius * Math.cos(angle)} y2={center + radius * Math.sin(angle)} stroke="currentColor" strokeOpacity="0.2" />
                );
            });

            // Labels
            const labels = data.map((d, i) => {
                const angle = i * angleSlice - Math.PI / 2;
                const r = radius + 15;
                const x = center + r * Math.cos(angle);
                const y = center + r * Math.sin(angle);
                return (
                    <text key={i} x={x} y={y} fontSize="9" textAnchor="middle" alignmentBaseline="middle" fill="currentColor" className="uppercase font-bold tracking-wider opacity-60">
                        {d.label}
                    </text>
                );
            });

            return (
                <svg width={size} height={size} className="text-slate-400 dark:text-zinc-500">
                    <circle cx={center} cy={center} r={radius} fill="none" stroke="currentColor" strokeOpacity="0.1" />
                    <circle cx={center} cy={center} r={radius * 0.5} fill="none" stroke="currentColor" strokeOpacity="0.1" />
                    {axes}
                    <polygon points={points} fill="rgba(99, 102, 241, 0.2)" stroke="#6366f1" strokeWidth="2" />
                    {labels}
                </svg>
            );
        };

        // --- MAIN APP ---
        function App() {
            const [view, setView] = useState('home');
            const [cards, setCards] = useState([]);
            const [history, setHistory] = useState([]);
            const [bookmarks, setBookmarks] = useState([]);
            const [wrongQueue, setWrongQueue] = useState([]); // ID list of mistakes
            const [streak, setStreak] = useState({ count: 0, lastDate: null, history: {} });
            const [activeDeck, setActiveDeck] = useState([]);
            const [toast, setToast] = useState(null);

            const [xp, setXp] = useState(() => parseInt(localStorage.getItem('ss_xp')) || 0);
            const [notes, setNotes] = useState({});
            const [srsData, setSrsData] = useState({});
            const [customCards, setCustomCards] = useState([]);
            const [showSettings, setShowSettings] = useState(false);
            const [showCreator, setShowCreator] = useState(false);
            const [theme, setTheme] = useState('prism-tomorrow');

            // Leveling Logic
            const level = Math.floor(Math.sqrt(xp / 25)) + 1;
            const nextLevelXp = Math.pow(level, 2) * 25;
            const prevLevelXp = Math.pow(level - 1, 2) * 25;
            const levelProgress = ((xp - prevLevelXp) / (nextLevelXp - prevLevelXp)) * 100;

            const addXp = (amount) => {
                const newXp = xp + amount;
                setXp(newXp);
                localStorage.setItem('ss_xp', newXp);
            };

            const showToast = (msg) => {
                setToast(msg);
                setTimeout(() => setToast(null), 3000);
            };
            const [darkMode, setDarkMode] = useState(false);

            useEffect(() => {
                // 1. Load Data
                // 1. Load Data
                const externalData = (typeof SEED_DATA !== 'undefined') ? SEED_DATA : [];
                const savedCustom = JSON.parse(localStorage.getItem('ss_custom_cards') || '[]');
                setCustomCards(savedCustom);
                setCards([...externalData, ...savedCustom]);

                // 2. Load Persisted State
                const h = localStorage.getItem('ss_history');
                const b = localStorage.getItem('ss_bookmarks');
                const w = localStorage.getItem('ss_wrongQueue');
                const s = localStorage.getItem('ss_streak');
                const d = localStorage.getItem('ss_dark');

                if (h) setHistory(JSON.parse(h));
                if (b) setBookmarks(JSON.parse(b));
                if (w) setWrongQueue(JSON.parse(w));
                if (s) setStreak(JSON.parse(s));

                // Load SRS Data
                const srs = localStorage.getItem('ss_srs_data');
                if (srs) setSrsData(JSON.parse(srs));

                const n = localStorage.getItem('ss_notes');
                if (n) setNotes(JSON.parse(n));

                // Dark Mode Init
                if (d === 'true') {
                    setDarkMode(true);
                    document.documentElement.classList.add('dark');
                }
            }, []);

            const toggleDarkMode = () => {
                const newVal = !darkMode;
                setDarkMode(newVal);
                if (newVal) document.documentElement.classList.add('dark');
                else document.documentElement.classList.remove('dark');
                localStorage.setItem('ss_dark', newVal);
            };

            const updateNotes = (cardId, text) => {
                const newNotes = { ...notes, [cardId]: text };
                setNotes(newNotes);
                localStorage.setItem('ss_notes', JSON.stringify(newNotes));
            };

            const updateHistory = (newHist) => { setHistory(newHist); localStorage.setItem('ss_history', JSON.stringify(newHist)); };
            const updateBookmarks = (newBook) => { setBookmarks(newBook); localStorage.setItem('ss_bookmarks', JSON.stringify(newBook)); };
            const updateWrongQueue = (newQ) => { setWrongQueue(newQ); localStorage.setItem('ss_wrongQueue', JSON.stringify(newQ)); };

            const updateStreak = () => {
                const today = new Date().toDateString();
                const newHistory = { ...streak.history, [today]: (streak.history[today] || 0) + 1 };

                let newCount = streak.count;
                if (streak.lastDate !== today) {
                    const yesterday = new Date();
                    yesterday.setDate(yesterday.getDate() - 1);
                    if (streak.lastDate === yesterday.toDateString()) newCount++;
                    else if (streak.lastDate !== today) newCount = 1;
                }

                const newStreak = { count: newCount, lastDate: today, history: newHistory };
                setStreak(newStreak);
                localStorage.setItem('ss_streak', JSON.stringify(newStreak));
            };

            // SRS Logic (Correctly scoped)
            const handleSrsReview = (id, rating) => {
                const NOW = Date.now();
                const existing = srsData[id] || { interval: 0, ease: 2.5, streak: 0 };
                let { interval, ease, street } = existing;
                let streak = existing.streak || 0;

                // Rating: 0=Again, 1=Hard, 2=Good, 3=Easy
                if (rating === SRS.AGAIN) {
                    streak = 0;
                    interval = 0; // 1 min
                } else if (rating === SRS.HARD) {
                    streak = 0;
                    interval = 0.5; // 12 hours
                } else if (rating === SRS.GOOD) {
                    streak++;
                    interval = streak === 1 ? 1 : interval * ease;
                } else if (rating === SRS.EASY) {
                    streak++;
                    ease += 0.15;
                    interval = streak === 1 ? 4 : interval * ease * 1.3;
                }

                if (ease < 1.3) ease = 1.3;

                // Calc Next Review (interval in days)
                let nextReview = NOW + (interval * 24 * 60 * 60 * 1000);
                if (interval === 0) nextReview = NOW + (60 * 1000); // 1 min

                const newData = { ...srsData, [id]: { interval, ease, streak, nextReview } };
                setSrsData(newData);
                localStorage.setItem('ss_srs_data', JSON.stringify(newData));

                // Legacy Sync
                if (rating >= SRS.GOOD) {
                    if (!history.includes(id)) updateHistory([...history, id]);
                    if (wrongQueue.includes(id)) updateWrongQueue(wrongQueue.filter(x => x !== id));
                } else {
                    if (!wrongQueue.includes(id)) updateWrongQueue([...wrongQueue, id]);
                }
            };



            const toggleBookmark = (id) => {
                if (bookmarks.includes(id)) updateBookmarks(bookmarks.filter(b => b !== id));
                else updateBookmarks([...bookmarks, id]);
            };

            const addCustomCard = (card) => {
                const newCustom = [...customCards, card];
                setCustomCards(newCustom);
                setCards([...cards, card]);
                localStorage.setItem('ss_custom_cards', JSON.stringify(newCustom));
                setShowCreator(false);
                showToast("Card Created!");
            };

            const exportData = () => {
                const data = { history, bookmarks, xp, streak, customCards, srsData, wrongQueue };
                const blob = new Blob([JSON.stringify(data)], { type: "application/json" });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `senior_swipe_backup_${new Date().toISOString().slice(0, 10)}.json`;
                link.click();
            };

            const importData = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (ev) => {
                    try {
                        const data = JSON.parse(ev.target.result);
                        if (data.history) updateHistory(data.history);
                        if (data.bookmarks) updateBookmarks(data.bookmarks);
                        if (data.xp) { setXp(data.xp); localStorage.setItem('ss_xp', data.xp); }
                        if (data.streak) { setStreak(data.streak); localStorage.setItem('ss_streak', JSON.stringify(data.streak)); }
                        if (data.customCards) {
                            setCustomCards(data.customCards);
                            localStorage.setItem('ss_custom_cards', JSON.stringify(data.customCards));
                            setCards([...cards, ...data.customCards]); // Note: This might duplicate if existing cards are not cleared, but SEED_DATA is constant.
                            setTimeout(() => window.location.reload(), 500);
                        }
                        if (data.srsData) { setSrsData(data.srsData); localStorage.setItem('ss_srs_data', JSON.stringify(data.srsData)); }
                        if (data.wrongQueue) updateWrongQueue(data.wrongQueue);
                        showToast("Data Restored!");
                        setShowSettings(false);
                    } catch (err) {
                        showToast("Invalid JSON file");
                    }
                };
                reader.readAsText(file);
            };

            const handleThemeChange = (newTheme) => {
                setTheme(newTheme);
                let link = document.getElementById('prism-theme-link');
                if (!link) {
                    link = document.createElement('link');
                    link.id = 'prism-theme-link';
                    link.rel = 'stylesheet';
                    document.head.appendChild(link);
                }

                // Maps
                if (newTheme === 'prism-tomorrow') link.href = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css";
                if (newTheme === 'prism-dracula') link.href = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-dracula.min.css";
                if (newTheme === 'prism-solarizedlight') link.href = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css";
                if (newTheme === 'prism-okaidia') link.href = "https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css";

                localStorage.setItem('ss_theme', newTheme);
            };

            useEffect(() => {
                const t = localStorage.getItem('ss_theme');
                if (t) handleThemeChange(t);
            }, []);

            const textToId = (text) => {
                // Simple hash to get ID from text if real ID missing
                return text.length;
            };

            const startSession = (category, mode = 'smart', sortMode = 'smart', range = null) => {
                let pool = [];

                if (category === 'Mistakes') {
                    pool = cards.filter(c => wrongQueue.includes(c.id));
                    if (pool.length === 0) { showToast("No mistakes to review!"); return; }
                } else if (category === 'Bookmarks') {
                    pool = cards.filter(c => bookmarks.includes(c.id));
                } else {
                    if (Array.isArray(category) && category.length > 0 && !category.includes('All')) {
                        pool = cards.filter(c => category.includes(c.category));
                    } else if (typeof category === 'string' && category !== 'All') {
                        pool = cards.filter(c => c.category === category);
                    } else {
                        pool = [...cards];
                    }
                }

                if (pool.length === 0) { showToast("No available cards."); return; }

                // Apply Sorting
                let finalDeck = [];
                if (sortMode === 'sequential') {
                    finalDeck = pool.sort((a, b) => parseInt(a.id) - parseInt(b.id));
                } else {
                    // Smart Shuffle
                    finalDeck = pool.map(c => {
                        let weight = 1;
                        // SRS Weighting
                        const srs = srsData[c.id];
                        if (srs) {
                            if (Date.now() > srs.nextReview) weight = 10; // Due for review
                            else weight = 0.1; // Not due
                        } else {
                            // New card
                            if (wrongQueue.includes(c.id)) weight = 5;
                            else if (!history.includes(c.id)) weight = 3;
                        }
                        return { card: c, sort: Math.random() * weight };
                    }).sort((a, b) => b.sort - a.sort).map(wp => wp.card);
                }

                // Apply Limit
                const limit = (range && range.limit) ? range.limit : 15;
                setActiveDeck(finalDeck.slice(0, limit));
                setView('play');
            };

            const handleSessionComplete = (learnedIds, newMistakes = []) => {
                updateHistory([...new Set([...history, ...learnedIds])]);
                updateWrongQueue([...new Set([...wrongQueue, ...newMistakes])]);
                updateStreak();
                addXp(50); // Session bonus
                setToast("Session Complete! +50 XP");
            };

            const renderView = () => {
                switch (view) {
                    case 'home': return <HomeView cards={cards} history={history} bookmarks={bookmarks} streak={streak} wrongQueue={wrongQueue} darkMode={darkMode} toggleDarkMode={toggleDarkMode} onStart={startSession} onNav={setView} xp={xp} level={level} levelProgress={levelProgress} setShowSettings={setShowSettings} setShowCreator={setShowCreator} srsData={srsData} updateStreak={updateStreak} />;
                    case 'browser': return <BrowserView cards={cards} bookmarks={bookmarks} onToggleBookmark={toggleBookmark} onNav={setView} />;
                    case 'play': return <PlayView deck={activeDeck} bookmarks={bookmarks} onToggleBookmark={toggleBookmark} onFinish={handleSessionComplete} onNav={setView} history={history} showToast={showToast} addXp={addXp} onSrsReview={handleSrsReview} notes={notes} onUpdateNote={updateNotes} />;
                    default: return <HomeView />;
                }
            };

            return (
                <div className="max-w-md mx-auto min-h-screen bg-white dark:bg-zinc-950 shadow-2xl overflow-hidden relative font-sans text-slate-800 dark:text-zinc-200">
                    <SettingsModal isOpen={showSettings} onClose={() => setShowSettings(false)} onExport={exportData} onImport={importData} currentTheme={theme} onThemeChange={handleThemeChange} />
                    {showCreator && <CardCreatorView categories={[...new Set(cards.map(c => c.category))]} onClose={() => setShowCreator(false)} onSave={addCustomCard} />}

                    {renderView()}
                    {toast && <Toast message={toast} />}
                </div>
            );
        }

        const HomeView = ({ cards, history, bookmarks, streak, wrongQueue, darkMode, toggleDarkMode, onStart, onNav, xp, level, levelProgress, setShowSettings, setShowCreator, srsData, updateStreak }) => {
            // Derive categories from cards
            const categories = useMemo(() => [...new Set(cards.map(c => c.category))], [cards]);

            // Calculate overall mastery
            const mastery = useMemo(() => {
                if (!cards.length) return 0;
                return (history.length / cards.length) * 100;
            }, [cards, history]);


            // Radar Data
            const radarData = useMemo(() => {
                const cats = categories.slice(0, 6); // Use actual top 6 categories
                return cats.map(cat => {
                    const catCards = cards.filter(c => c.category === cat);
                    if (!catCards.length) return { label: cat, value: 0 };
                    const learned = catCards.filter(c => history.includes(c.id)).length;
                    // Boost value if SRS says "easy"
                    const mastery = (learned / catCards.length) * 100;
                    return { label: cat, value: mastery || 10 }; // Min 10 for visibility
                });
            }, [cards, history]);

            // Heatmap Data (Last 7 days)
            const dates = [];
            for (let i = 6; i >= 0; i--) {
                const d = new Date(); d.setDate(d.getDate() - i);
                dates.push(d.toDateString());
            }

            const [selectedCats, setSelectedCats] = useState([]);
            const [isSelectMode, setIsSelectMode] = useState(false);
            const [catSort, setCatSort] = useState('default'); // default, count_desc, count_asc

            const getCategoryCount = (cat) => cards.filter(c => c.category === cat).length;

            const displayCategories = useMemo(() => {
                let sorted = [...categories];
                if (catSort === 'count_desc') return sorted.sort((a, b) => getCategoryCount(b) - getCategoryCount(a));
                if (catSort === 'count_asc') return sorted.sort((a, b) => getCategoryCount(a) - getCategoryCount(b));
                return sorted;
            }, [categories, catSort]);

            const toggleCatSort = () => {
                if (catSort === 'default') setCatSort('count_desc');
                else if (catSort === 'count_desc') setCatSort('count_asc');
                else setCatSort('default');
            };

            const toggleCategorySelect = (cat) => {
                if (selectedCats.includes(cat)) {
                    const newCats = selectedCats.filter(c => c !== cat);
                    setSelectedCats(newCats);
                } else {
                    setSelectedCats([...selectedCats, cat]);
                }
            };

            const handleStartSession = () => {
                if (selectedCats.length === 0) {
                    // If nothing selected, maybe select all? Or show error.
                    // Making "Select None" = "Start All" is a valid pattern, 
                    // but floating button usually implies explicit selection.
                    // The user asked for "multiselect from it".
                    // Let's assume if they click the FAB, they want to start with selected.
                    // If FAB is only shown when selected > 0, we are good.
                    onStart(selectedCats, 'study');
                } else {
                    onStart(selectedCats, 'study');
                }
            };

            const [showRoadmap, setShowRoadmap] = useState(false);

            return (
                <div className="min-h-screen bg-slate-50 dark:bg-zinc-950 relative pb-32">
                    <LevelRoadmapModal isOpen={showRoadmap} onClose={() => setShowRoadmap(false)} currentXp={xp} currentLevel={level} />

                    <div className="p-6 bg-white dark:bg-zinc-950 border-b border-slate-200 dark:border-zinc-800">
                        <div className="flex justify-between items-center mb-4">
                            <div className="flex items-center gap-3">
                                <img src="icon.png" className="w-8 h-8 rounded-lg shadow-sm" alt="Logo" />
                                <div className="cursor-pointer" onClick={() => setShowRoadmap(true)}>
                                    <h1 className="text-xl font-black text-slate-800 dark:text-white leading-none">Senior Swipe</h1>
                                    <div className="text-[10px] font-bold text-indigo-500 uppercase tracking-widest mt-1 flex items-center gap-1">Lv.{level} Developer <Icons.Wrench size={10} /></div>
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button onClick={toggleDarkMode} className="p-2 bg-slate-100 dark:bg-zinc-800 text-slate-600 dark:text-zinc-400 rounded-full">{darkMode ? <Icons.Sun /> : <Icons.Moon />}</button>
                                <button onClick={() => updateStreak() || setShowSettings(true)} className="p-2 bg-slate-100 dark:bg-zinc-800 text-slate-600 dark:text-zinc-400 rounded-full"><Icons.Wrench /></button> {/* Settings shortcut */}
                                <button onClick={() => onNav('browser')} className="p-2 bg-indigo-50 dark:bg-indigo-900/30 text-indigo-600 dark:text-indigo-400 rounded-full"><Icons.Search /></button>
                            </div>
                        </div>
                        <div className="bg-zinc-900 dark:bg-zinc-900 text-white p-5 rounded-2xl shadow-lg border border-zinc-800 relative overflow-hidden">
                            {/* Level Progress Background */}
                            <div className="absolute top-0 left-0 h-1 bg-gradient-to-r from-indigo-500 via-purple-500 to-pink-500" style={{ width: `${levelProgress}%` }}></div>

                            <div className="flex justify-between items-center mb-4">
                                <div className="flex items-center gap-2 text-yellow-400 font-bold"><Icons.Flame fill="currentColor" /> {streak.count} Day Streak</div>
                                <div className="flex gap-1">{dates.map(d => <div key={d} className={`w-2 h-6 rounded-full ${streak.history[d] ? 'bg-green-500' : 'bg-zinc-700'}`}></div>)}</div>
                            </div>
                            <div className="flex justify-between text-sm mb-1 text-slate-400"><span>Mastery</span><span>{history.length} / {cards.length}</span></div>
                            <div className="w-full bg-zinc-800 h-2 rounded-full overflow-hidden mb-4"><div className="bg-indigo-500 h-full transition-all duration-1000" style={{ width: `${mastery}%` }}></div></div>
                            <div className="flex gap-4">
                                <div className="flex-1 bg-zinc-800 rounded-lg p-2 text-center clickable" onClick={() => onStart('Bookmarks', 'study')}><div className="text-xl font-bold text-yellow-400">{bookmarks.length}</div><div className="text-[10px] uppercase tracking-wider text-slate-400">Bookmarks</div></div>
                                <div className="flex-1 bg-zinc-800 rounded-lg p-2 text-center" onClick={() => onStart('Mistakes', 'study')}><div className="text-xl font-bold text-red-400">{wrongQueue.length}</div><div className="text-[10px] uppercase tracking-wider text-slate-400">Mistakes</div></div>
                            </div>
                            <div className="flex justify-center mt-6">
                                <RadarChart data={radarData} size={220} />
                            </div>
                        </div>
                    </div>

                    <div className="pt-4">
                        <div className="px-6 flex justify-between items-center mb-4">
                            <h2 className="font-bold text-slate-700 dark:text-zinc-500 text-sm uppercase tracking-wide">Browse Categories</h2>
                            <button onClick={() => setShowCreator(true)} className="text-xs font-bold text-indigo-600">+ New Card</button>
                        </div>
                        <div className="grid grid-cols-2 gap-3 px-6">
                            {displayCategories.map(cat => {
                                const isSelected = selectedCats.includes(cat);
                                const count = getCategoryCount(cat);
                                return (
                                    <div key={cat} onClick={() => toggleCategorySelect(cat)} className={`p-4 rounded-xl border-2 cursor-pointer transition-all ${isSelected ? 'border-indigo-600 bg-indigo-50 dark:bg-indigo-900/20 dark:border-indigo-500' : 'border-slate-200 dark:border-zinc-800 bg-white dark:bg-zinc-900 hover:border-indigo-300 dark:hover:border-indigo-700'}`}>
                                        <div className="flex justify-between items-start mb-2">
                                            <div className={`w-4 h-4 rounded-full border border-slate-300 flex items-center justify-center ${isSelected ? 'bg-indigo-600 border-indigo-600' : ''}`}>
                                                {isSelected && <Icons.CheckCircle size={12} className="text-white" />}
                                            </div>
                                            <span className="text-[10px] font-bold text-slate-400">{count}</span>
                                        </div>
                                        <h3 className="font-bold text-slate-800 dark:text-white text-sm line-clamp-2 mb-2">{cat}</h3>
                                        <div className="flex flex-wrap gap-1">
                                            {[...new Set(cards.filter(c => c.category === cat).map(c => c.difficulty))].map(diff => (
                                                <span key={diff} className={`text-[9px] px-1.5 py-0.5 rounded-[4px] font-bold tracking-wider uppercase ${diff === 'Senior' ? 'bg-red-100 text-red-600 dark:bg-red-900/30 dark:text-red-300' : diff === 'Principal' ? 'bg-purple-100 text-purple-600 dark:bg-purple-900/30 dark:text-purple-300' : 'bg-green-100 text-green-600'}`}>{diff}</span>
                                            ))}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    </div>

                    {/* Floating Action Button */}
                    <div className={`fixed bottom-6 left-1/2 -translate-x-1/2 z-50 transition-all duration-300 ${selectedCats.length > 0 ? 'translate-y-0 opacity-100' : 'translate-y-20 opacity-0'}`}>
                        <button onClick={() => setIsSelectMode(true)} className="bg-indigo-600 text-white px-8 py-4 rounded-full font-bold shadow-2xl flex items-center gap-3 hover:scale-105 active:scale-95 transition-transform">
                            <Icons.Play size={20} fill="currentColor" />
                            Start Session ({selectedCats.length})
                        </button>
                    </div>

                    <SessionSetupModal
                        isOpen={isSelectMode}
                        onClose={() => setIsSelectMode(false)}
                        onStart={(mode, range) => onStart(selectedCats, 'study', mode, range)}
                        totalCards={cards.length}
                    />
                </div>
            );
        };

        const BrowserView = ({ cards, bookmarks, onToggleBookmark, onNav }) => {
            const [search, setSearch] = useState('');
            const [categoryFilter, setCategoryFilter] = useState('All');
            const [sortOrder, setSortOrder] = useState('default'); // default, id_asc, id_desc
            const [expandedIds, setExpandedIds] = useState([]);
            const categories = ['All', ...new Set(cards.map(c => c.category))];

            const toggleExpand = (id) => {
                if (expandedIds.includes(id)) setExpandedIds(expandedIds.filter(i => i !== id));
                else setExpandedIds([...expandedIds, id]);
            };

            const filtered = cards.filter(c => {
                const matchesSearch = c.title.toLowerCase().includes(search.toLowerCase()) || c.content.toLowerCase().includes(search.toLowerCase());
                const matchesCategory = categoryFilter === 'All' || c.category === categoryFilter;
                return matchesSearch && matchesCategory;
            });

            const sorted = [...filtered].sort((a, b) => {
                if (sortOrder === 'id_asc') return parseInt(a.id) - parseInt(b.id);
                if (sortOrder === 'id_desc') return parseInt(b.id) - parseInt(a.id);
                return 0; // Default natural order
            });

            const displayList = sorted.slice(0, 50);

            const toggleSort = () => {
                if (sortOrder === 'default') setSortOrder('id_asc');
                else if (sortOrder === 'id_asc') setSortOrder('id_desc');
                else setSortOrder('default');
            };

            return (
                <div className="flex flex-col h-screen bg-slate-50 dark:bg-zinc-950">
                    <div className="p-4 bg-white dark:bg-zinc-950 border-b border-slate-200 dark:border-zinc-800 sticky top-0 z-10">
                        <div className="flex flex-col gap-3 mb-3">
                            <div className="flex items-center gap-3">
                                <button onClick={() => onNav('home')} className="p-2 hover:bg-slate-100 dark:hover:bg-zinc-800 rounded-full dark:text-white"><Icons.Home /></button>
                                <div className="flex-1 relative"><input type="text" placeholder="Search..." className="w-full pl-9 pr-4 py-2 bg-slate-100 dark:bg-zinc-900 dark:text-white rounded-full text-sm focus:outline-none focus:ring-2 focus:ring-indigo-500" value={search} onChange={e => setSearch(e.target.value)} /><Icons.Search className="absolute left-3 top-2.5 w-4 h-4 text-slate-400 dark:text-zinc-500" /></div>
                                <button onClick={toggleSort} className={`p-2 rounded-full transition-colors ${sortOrder !== 'default' ? 'bg-indigo-100 text-indigo-600 dark:bg-indigo-900 dark:text-indigo-400' : 'bg-slate-100 dark:bg-zinc-800 text-slate-500 dark:text-zinc-400'}`}>
                                    {sortOrder === 'id_asc' ? <Icons.Filter className="rotate-180" /> : <Icons.Filter />}
                                </button>
                            </div>
                            <div className="flex gap-2 overflow-x-auto no-scrollbar">
                                {categories.map(cat => (
                                    <button key={cat} onClick={() => setCategoryFilter(cat)} className={`px-3 py-1 rounded-full text-[10px] font-bold whitespace-nowrap transition-colors border ${categoryFilter === cat ? 'bg-indigo-600 text-white border-indigo-600' : 'bg-slate-100 dark:bg-zinc-900 text-slate-500 dark:text-zinc-400 border-transparent'}`}>{cat}</button>
                                ))}
                            </div>
                        </div>
                    </div>
                    <div className="flex-1 overflow-y-auto p-4 space-y-3">
                        {displayList.map(c => (
                            <div key={c.id} className="bg-white dark:bg-zinc-900 rounded-xl shadow-sm border border-slate-200 dark:border-zinc-800 p-4">
                                <div className="flex justify-between items-start mb-2">
                                    <div className="flex items-center gap-2">
                                        <span className={`text-[10px] px-2 py-0.5 rounded-full font-bold bg-slate-100 dark:bg-zinc-800 text-slate-500 dark:text-zinc-400`}>{c.category}</span>
                                        <span className="text-[9px] font-mono text-slate-300 dark:text-zinc-600">#{c.id}</span>
                                    </div>
                                    <div className="flex gap-2">
                                        <button onClick={() => toggleExpand(c.id)} className="text-slate-400 dark:text-zinc-500 text-[10px] font-bold px-2 py-1 rounded bg-slate-100 dark:bg-zinc-800 uppercase tracking-widest hover:bg-indigo-50 dark:hover:bg-indigo-900 hover:text-indigo-600 dark:hover:text-indigo-400 transition-colors">{expandedIds.includes(c.id) ? 'Collapse' : 'Expand'}</button>
                                        <button onClick={() => onToggleBookmark(c.id)} className={bookmarks.includes(c.id) ? "text-yellow-400" : "text-slate-300 dark:text-zinc-600"}><Icons.Bookmark size={18} fill="currentColor" /></button>
                                    </div>
                                </div>
                                <h3 className="font-bold text-slate-800 dark:text-white text-sm mb-2">{c.title}</h3>
                                <div className={`text-xs text-slate-500 dark:text-zinc-400 ${expandedIds.includes(c.id) ? '' : 'line-clamp-2'}`}><Markdown content={c.content} /></div>
                                {expandedIds.includes(c.id) && <div className="mt-4 pt-4 border-t border-slate-100 dark:border-zinc-800"><div className="text-[10px] font-bold text-slate-400 dark:text-zinc-500 uppercase tracking-widest mb-2">Explanation</div><div className="text-xs text-slate-600 dark:text-zinc-300"><Markdown content={c.explanation} /></div></div>}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        const PlayView = ({ deck, bookmarks, onToggleBookmark, onFinish, onNav, history, showToast, addXp, onSrsReview, notes, onUpdateNote }) => {
            const [index, setIndex] = useState(0);
            const [isFlipped, setIsFlipped] = useState(false);
            const [localLearned, setLocalLearned] = useState([]);
            const [showConfetti, setShowConfetti] = useState(false);

            // Modes
            const [commuterMode, setCommuterMode] = useState(false);
            const [interviewMode, setInterviewMode] = useState(false);

            // Interview State
            const [timer, setTimer] = useState(120);
            const [isRecording, setIsRecording] = useState(false);
            const [audioUrl, setAudioUrl] = useState(null);
            const mediaRecorder = useRef(null);
            const audioChunks = useRef([]);

            // Commuter State
            const synth = window.speechSynthesis;
            const uttr = useRef(new SpeechSynthesisUtterance());

            // Commuter Logic
            useEffect(() => {
                if (!commuterMode) {
                    synth.cancel();
                    return;
                }

                // Sequence: Read Q -> Wait 5s -> Read A -> Wait 2s -> Next
                const readCard = () => {
                    if (!card) return;

                    // Step 1: Read Question
                    uttr.current.text = `Question. ${card.title}. ${card.content}`;
                    uttr.current.onend = () => {
                        // Step 2: Wait 5s
                        setTimeout(() => {
                            if (!commuterMode) return;
                            // Step 3: Flip & Read Answer
                            setIsFlipped(true);
                            uttr.current.text = `Answer. ${card.explanation}`;
                            uttr.current.onend = () => {
                                // Step 4: Next Card
                                setTimeout(() => {
                                    if (!commuterMode) return;
                                    handleSrs(2); // Auto-mark "Good"
                                }, 2000);
                            };
                            synth.speak(uttr.current);
                        }, 5000);
                    };
                    synth.speak(uttr.current);
                };

                readCard();

                return () => synth.cancel();
            }, [commuterMode, index]); // effect runs when index changes to read next card

            // Interview Timer
            useEffect(() => {
                let interval;
                if (interviewMode && !isFlipped && timer > 0) {
                    interval = setInterval(() => setTimer(t => t - 1), 1000);
                }
                return () => clearInterval(interval);
            }, [interviewMode, isFlipped, timer]);

            // Audio Recording
            const toggleRecording = async () => {
                if (isRecording) {
                    mediaRecorder.current.stop();
                    setIsRecording(false);
                } else {
                    try {
                        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                        mediaRecorder.current = new MediaRecorder(stream);
                        audioChunks.current = [];

                        mediaRecorder.current.ondataavailable = (e) => audioChunks.current.push(e.data);
                        mediaRecorder.current.onstop = () => {
                            const blob = new Blob(audioChunks.current, { type: 'audio/webm' });
                            setAudioUrl(URL.createObjectURL(blob));
                        };

                        mediaRecorder.current.start();
                        setIsRecording(true);
                    } catch (e) {
                        showToast("Microphone access denied");
                    }
                }
            };

            const card = deck[index] || {};
            const isLast = index === deck.length - 1;
            const hasLearned = history.includes(card?.id) || localLearned.includes(card?.id);

            // --- TOUCH / SWIPE LOGIC ---
            const [touchStart, setTouchStart] = useState(null);
            const [touchEnd, setTouchEnd] = useState(null);
            const [swipeOffset, setSwipeOffset] = useState(0);

            const minSwipeDistance = 100;

            const onTouchStart = (e) => {
                setTouchEnd(null);
                setTouchStart(e.targetTouches[0].clientX);
            };

            const onTouchMove = (e) => {
                setTouchEnd(e.targetTouches[0].clientX);
                if (touchStart) {
                    const current = e.targetTouches[0].clientX;
                    setSwipeOffset(current - touchStart);
                }
            };

            const onTouchEnd = () => {
                if (!touchStart || !touchEnd) return;
                const distance = touchStart - touchEnd;
                const isLeftSwipe = distance > minSwipeDistance;
                const isRightSwipe = distance < -minSwipeDistance;

                if (isLeftSwipe) {
                    // Swipe Left (Hard/Next)
                    handleSwipeAction('left');
                } else if (isRightSwipe) {
                    // Swipe Right (Easy/Learned)
                    handleSwipeAction('right');
                } else {
                    // Reset
                    setSwipeOffset(0);
                }
                setTouchStart(null);
                setTouchEnd(null);
            };

            const handleSwipeAction = (dir) => {
                if (dir === 'left') {
                    // Hard / Review Later
                    handleSrs(1); // Hard
                } else {
                    // Easy / Learned
                    handleSrs(3); // Easy
                }
            };

            const handleSrs = (rating) => {
                // 0=Again, 1=Hard, 2=Good, 3=Easy
                if (onSrsReview) onSrsReview(card.id, rating);

                // Animation & Next
                const dir = rating >= 2 ? 'right' : 'left';
                triggerAnim(dir === 'right' ? 'next' : 'prev');
                setCardAnim(dir === 'right' ? 'card-exit-right' : 'card-exit-left'); // Swipe right exits right, left exits left

                addXp(rating >= 2 ? 10 : 2);
                showToast(rating >= 2 ? "Learned! +10 XP" : "Reviewing later");

                setTimeout(() => {
                    setIsFlipped(false);
                    setSwipeOffset(0);
                    if (isLast) finishSession();
                    else {
                        setIndex(index + 1);
                        setCardAnim('card-enter-bottom'); // New card comes from bottom or side
                        setTimeout(() => setCardAnim(''), 200);
                    }
                }, 200);
            };

            // Allow keyboard shortcuts too?
            useEffect(() => {
                const handleKey = (e) => {
                    if (e.key === 'ArrowRight') handleSrs(3);
                    if (e.key === 'ArrowLeft') handleSrs(1);
                    if (e.key === ' ') setIsFlipped(p => !p);
                };
                window.addEventListener('keydown', handleKey);
                return () => window.removeEventListener('keydown', handleKey);
            }, [index, isFlipped]);

            const finishSession = () => {
                setShowConfetti(true);
                setTimeout(() => {
                    onFinish(localLearned, []); // Pass tracked mistakes if any, currently simplistic
                    onNav('home');
                }, 3000);
            };

            const [animState, setAnimState] = useState({ prev: false, next: false });
            const [cardAnim, setCardAnim] = useState('');

            const triggerAnim = (dir) => {
                setAnimState(prev => ({ ...prev, [dir]: true }));
                setTimeout(() => setAnimState(prev => ({ ...prev, [dir]: false })), 200);
            };

            const nextCard = () => {
                triggerAnim('next');

                // XP Logic: Apply XP when moving to next card (if not just browsing back)
                addXp(10);
                showToast("+10 XP");

                setCardAnim('card-exit-left');
                setTimeout(() => {
                    setIsFlipped(false);
                    if (isLast) finishSession();
                    else {
                        setIndex(index + 1);
                        setCardAnim('card-enter-right');
                        setTimeout(() => setCardAnim(''), 200);
                    }
                }, 200);
            };

            const prevCard = () => {
                triggerAnim('prev');
                if (index > 0) {
                    setCardAnim('card-exit-right');
                    setTimeout(() => {
                        setIsFlipped(false);
                        setIndex(index - 1);
                        setCardAnim('card-enter-left');
                        setTimeout(() => setCardAnim(''), 200);
                    }, 200);
                }
            };

            const toggleLearned = (e) => {
                e.stopPropagation();
                if (localLearned.includes(card.id)) setLocalLearned(localLearned.filter(id => id !== card.id));
                else setLocalLearned([...localLearned, card.id]);
            };

            const copyPrompt = (e) => {
                e.stopPropagation();
                const prompt = `Topic: ${card.title}\n\nQuestion:\n${card.content}\n\nAnswer:\n${card.explanation}\n\nPlease explain this interview question and answer in detail and explain why it matters for a senior dev.`;
                navigator.clipboard.writeText(prompt);
                showToast("Full context copied to clipboard!");
            };

            if (!card) return null;

            // Rotation with swipe
            const swipeRotation = swipeOffset / 20; // 200px -> 10deg
            const swipeOpacity = Math.max(0, 1 - Math.abs(swipeOffset) / 500);
            const style = {
                transform: `translateX(${swipeOffset}px) rotate(${swipeRotation}deg) ${isFlipped ? 'rotateY(180deg)' : ''}`,
                opacity: isFlipped ? 1 : Math.min(1, Math.max(0.5, 1 - Math.abs(swipeOffset) / 1000))
            };

            return (
                <div className="h-screen bg-slate-100 dark:bg-zinc-950 flex flex-col relative overflow-hidden">
                    {showConfetti && <SimpleConfetti />}
                    {/* Header */}
                    <div className="p-4 flex justify-between items-center z-10">
                        <button onClick={() => onNav('home')} className="text-slate-400 p-2"><Icons.X /></button>
                        <div className="text-xs font-bold text-slate-400 bg-white dark:bg-zinc-900 px-3 py-1 rounded-full shadow-sm">
                            {interviewMode ? <span className={`text-${timer < 30 ? 'red' : 'indigo'}-500`}>{Math.floor(timer / 60)}:{(timer % 60).toString().padStart(2, '0')}</span> : `${index + 1} / ${deck.length}`}
                        </div>
                        <div className="flex gap-2">
                            <button onClick={() => { setCommuterMode(!commuterMode); setInterviewMode(false); }} className={`p-2 rounded-full ${commuterMode ? 'bg-indigo-600 text-white' : 'text-slate-300 dark:text-zinc-600'}`}><Icons.Headphones size={20} /></button>
                            <button onClick={() => { setInterviewMode(!interviewMode); setCommuterMode(false); setTimer(120); }} className={`p-2 rounded-full ${interviewMode ? 'bg-indigo-600 text-white' : 'text-slate-300 dark:text-zinc-600'}`}><Icons.Mic size={20} /></button>
                            <button onClick={() => onToggleBookmark(card.id)} className={bookmarks.includes(card.id) ? "text-yellow-400 p-2" : "text-slate-300 dark:text-zinc-600 p-2"}><Icons.Bookmark fill={bookmarks.includes(card.id) ? "currentColor" : "none"} /></button>
                        </div>
                    </div>

                    {/* Card Container - Refactored for full content visibility */}
                    <div className="flex-1 flex items-start justify-center p-6 overflow-y-auto">
                        <div className={`relative w-full max-w-sm transition-all duration-300 cursor-pointer ${cardAnim}`} onClick={() => setIsFlipped(!isFlipped)}>
                            {!isFlipped ? (
                                /* FRONT */
                                <div className="bg-white dark:bg-zinc-900 rounded-3xl shadow-xl border border-slate-200 dark:border-zinc-800 flex flex-col min-h-[50vh]">
                                    <div className="bg-slate-50 dark:bg-zinc-800/50 p-6 border-b border-slate-100 dark:border-zinc-800 text-center select-none">
                                        <span className="text-[10px] px-2 py-1 rounded-full font-bold tracking-wider uppercase bg-slate-200 text-slate-600 dark:bg-zinc-700 dark:text-zinc-300 mr-2">{card.category}</span>
                                        <span className={`text-[10px] px-2 py-1 rounded-full font-bold tracking-wider uppercase ${card.difficulty === 'Senior' ? 'bg-red-100 text-red-600 dark:bg-red-900/30 dark:text-red-300' : card.difficulty === 'Principal' ? 'bg-purple-100 text-purple-600 dark:bg-purple-900/30 dark:text-purple-300' : 'bg-green-100 text-green-600'}`}>{card.difficulty || 'General'}</span>
                                        <h3 className="text-xl font-bold text-slate-800 dark:text-white mt-3">{card.title}</h3>
                                    </div>
                                    <div className="flex-1 p-8">
                                        <div className="w-full text-base text-slate-700 dark:text-zinc-300 leading-relaxed font-medium"><Markdown content={card.content} /></div>
                                    </div>
                                    <div className="p-4 text-center text-xs text-slate-300 dark:text-zinc-600 font-bold uppercase tracking-widest animate-pulse border-t border-slate-100 dark:border-zinc-800">
                                        Tap to Reveal Answer
                                    </div>
                                </div>
                            ) : (
                                /* BACK */
                                <div className="bg-indigo-50 dark:bg-zinc-900 rounded-3xl shadow-xl border-2 border-indigo-100 dark:border-indigo-900/50 flex flex-col min-h-[50vh]">
                                    <div className="bg-indigo-100 dark:bg-indigo-900/20 p-4 border-b border-indigo-200 dark:border-indigo-900/50 flex justify-between items-center">
                                        <h3 className="text-sm font-bold text-indigo-800 dark:text-indigo-300 uppercase tracking-widest">Explanation</h3>
                                    </div>
                                    <div className="flex-1 p-8 bg-white dark:bg-zinc-900/50">
                                        <div className="text-base text-slate-700 dark:text-zinc-300 leading-relaxed whitespace-pre-wrap"><Markdown content={card.explanation} /></div>
                                    </div>

                                    <div className="p-2 flex justify-center gap-4 bg-indigo-50 dark:bg-indigo-900/10 border-t border-indigo-100 dark:border-zinc-800">
                                        <button onClick={copyPrompt} className="p-2 text-indigo-400 hover:text-indigo-600 flex items-center gap-2 text-xs font-bold uppercase tracking-wide"><Icons.Robot size={18} /> Ask AI</button>
                                    </div>

                                    <div className="p-4 border-t border-slate-100 dark:border-zinc-800 bg-slate-50 dark:bg-zinc-900/50">
                                        <textarea
                                            className="w-full bg-transparent text-xs text-slate-600 dark:text-zinc-400 placeholder-slate-300 dark:placeholder-zinc-600 resize-none focus:outline-none"
                                            placeholder="Add personal notes here..."
                                            rows={3}
                                            value={notes[card.id] || ''}
                                            onChange={(e) => onUpdateNote(card.id, e.target.value)}
                                            onClick={e => e.stopPropagation()}
                                        />
                                    </div>

                                    {/* SRS Actions */}
                                    <div className="grid grid-cols-4 gap-1 p-2 bg-white dark:bg-zinc-900 border-t border-slate-100 dark:border-zinc-800">
                                        <button onClick={(e) => { e.stopPropagation(); handleSrs(0); }} className="flex flex-col items-center p-2 rounded-lg hover:bg-slate-50 dark:hover:bg-zinc-800">
                                            <span className="text-[10px] font-bold text-red-500 uppercase">Again</span>
                                            <span className="text-[9px] text-slate-400">1m</span>
                                        </button>
                                        <button onClick={(e) => { e.stopPropagation(); handleSrs(1); }} className="flex flex-col items-center p-2 rounded-lg hover:bg-slate-50 dark:hover:bg-zinc-800">
                                            <span className="text-[10px] font-bold text-orange-500 uppercase">Hard</span>
                                            <span className="text-[9px] text-slate-400">12h</span>
                                        </button>
                                        <button onClick={(e) => { e.stopPropagation(); handleSrs(2); }} className="flex flex-col items-center p-2 rounded-lg hover:bg-slate-50 dark:hover:bg-zinc-800">
                                            <span className="text-[10px] font-bold text-green-500 uppercase">Good</span>
                                            <span className="text-[9px] text-slate-400">1d</span>
                                        </button>
                                        <button onClick={(e) => { e.stopPropagation(); handleSrs(3); }} className="flex flex-col items-center p-2 rounded-lg hover:bg-slate-50 dark:hover:bg-zinc-800">
                                            <span className="text-[10px] font-bold text-blue-500 uppercase">Easy</span>
                                            <span className="text-[9px] text-slate-400">4d</span>
                                        </button>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                    {/* Navigation Buttons */}
                    {/* Navigation Buttons (Fallback) */}
                    <div className="p-8 pb-12 flex justify-center gap-6 z-10">
                        <div className="absolute top-1/2 left-4 -translate-y-1/2 opacity-20 pointer-events-none"><Icons.X size={48} className="text-red-500" /></div>
                        <div className="absolute top-1/2 right-4 -translate-y-1/2 opacity-20 pointer-events-none"><Icons.CheckCircle size={48} className="text-green-500" /></div>

                        {!isFlipped && (
                            <div className="flex gap-4 items-center">
                                <span className="text-xs font-bold text-slate-400 opacity-50"><Icon path={<path d="m15 18-6-6 6-6" />} size={16} /> Swipe Left</span>
                                <span className="text-xs font-bold text-slate-400 opacity-50">Swipe Right <Icon path={<path d="m9 18 6-6-6-6" />} size={16} /></span>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>